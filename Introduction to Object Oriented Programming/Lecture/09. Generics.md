# Generics

## Recall Method Overloading
* A language feature that allows a class to have multiple methods with the same name, but different parameter lists
```java
public static void printArray(Integer[] array) {
  for (Integer element : array)
    System.out.printf("%s ", element);
  System.out.println();
}
public static void printArray(Double[] array) {
  for (Double element : array)
    System.out.printf("%s ", element);
  System.out.println();
}
public static void printArray(Character[] array) {
  for (Character element : array)
    System.out.printf("%s ", element);
  System.out.println();
}
```
## Using overloaded methods
```java
public static void main(String[] args) {
		Integer[] integerArray = { 1, 2, 3, 4, 5, 6 }; // autoboxing
		Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4, 5.5 }; // autoboxing
		Character[] characterArray = { 'H', 'E', 'L', 'L', 'O' }; // autoboxing
		System.out.print("integerArray contains: ");
		printArray(integerArray);
		System.out.print("doubleArray contains: ");
		printArray(doubleArray);
		System.out.print("characterArray contains: ");
		printArray(characterArray);
}
```
Output
```
integerArray contains: 1 2 3 4 5 6 
doubleArray contains: 1.1 2.2 3.3 4.4 5.5 
characterArray contains: H E L L O 
```

### Looks good, but wait...
```java
public static void printArray(Integer[] array) {
  for (Integer element : array)
  System.out.printf("%s ", element);
  System.out.println();
}
public static void printArray(Double[] array) {
  for (Double element : array)
  System.out.printf("%s ", element);
  System.out.println();
}
public static void printArray(Character[] array) {
  for (Character element : array)
  System.out.printf("%s ", element);
  System.out.println();
}
```
* Question: These methods are identical except the data type part. If the input is Long[] or String[], shall we continue the overloading?
  -  Yes, you can continue overloading the `printArray` method for other data types like `Long[]` and `String[]`. You can simply add a new method that takes an array of the desired type and follows the same structure as the existing methods. 
  -  For example, you could add the following method to print an array of `Long` values:
    ```java
    public static void printArray(Long[] array) {
      for (Long element : array)
        System.out.printf("%s ", element);
      System.out.println();
    }
    ```
  - Similarly, you could add another method to print an array of `String` values:
    ```java
    public static void printArray(String[] array) {
      for (String element : array)
        System.out.printf("%s ", element);
      System.out.println();
    }
    ```
  - By overloading the `printArray` method for different data types, you can reuse the same code structure and simplify your program

# A better design with generics
* if the operations performed by several overloaded methods are identical for each argument type, the overloaded methods can be more compactly coded using a generic method
  ```java
  public static <T> void printArray(T[] array) {
    for (T element : array)
      System.out.printf("%s ", element);
    System.out.println();
  }
  ```
  > Type-parameter sections: one or more type parameters delimited by <> Each type parameter parameterizeds the data types that can be used in the method (in the above example, T can be used anywhere a data type name is expected)

## Declaring neneric methods
* Generic methods can be delcared like any other normal methods
* Type parameters can represnet only reference types (not primitive tyeps)
  ```java
  public static void printArray(Double[] array) {
		for (Double element : array)
		  System.out.printf("%s ", element);
		System.out.println();
	}
	
	public static <T> void printArray(T[] array) {
		for (T element : array)
		  System.out.printf("%s ", element);
		System.out.println();
	}
  ```
## Using generic methods
```java
public static void main(String[] args) {
		Integer[] integerArray = { 1, 2, 3, 4, 5, 6 }; // autoboxing
		Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4, 5.5 }; // autoboxing
		Character[] characterArray = { 'H', 'E', 'L', 'L', 'O' }; // autoboxing
		System.out.print("integerArray contains: ");
		printArray(integerArray);
		System.out.print("doubleArray contains: ");
		printArray(doubleArray);
		System.out.print("characterArray contains: ");
		printArray(characterArray);
}
```
Output
```
integerArray contains: 1 2 3 4 5 6 
doubleArray contains: 1.1 2.2 3.3 4.4 5.5 
characterArray contains: H E L L O 
```

## Under the hood: Erasure
* When the compiler translates generic method `printArray` into Java bytecodes, it **removes the type-parameter section** and **replaces the type parameters with actual types**. This process is know as **erasure**
* By default, all generic types are replaced with type **Object**
* The compiled version of `printArray` is shown below 
  ```java
  public static void printArray(Object[] array) {
    for (Object element : array)
      System.out.printf("%s ", element);
    System.out.println();
  }
  ```

## Benefits of generic methods
* Using generic -> Object array as parametr of `printArray`
```java
public static void main(String[] args) {
		Integer[] integerArray = { 1, 2, 3, 4, 5, 6 }; // autoboxing
		Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4, 5.5 }; // autoboxing
		Character[] characterArray = { 'H', 'E', 'L', 'L', 'O' }; // autoboxing
		System.out.print("integerArray contains: ");
		printArray(integerArray);
		System.out.print("doubleArray contains: ");
		printArray(doubleArray);
		System.out.print("characterArray contains: ");
		printArray(characterArray);
}

public static void printArray(Double[] array) {
  for (Double element : array)
  System.out.printf("%s ", element);
  System.out.println();
}
```
```java
public static Object simplyReturn(Object o) {
  return o;
}
public static void main(String[] args) {
  String s = simplyReturn("hello");
}
```
* The complier sees that method return type is Object, assigning a reference of Object to a String variable is illegal, so a compilation error will occur
* Programmers need to perform `explicit type case: (String) simplyReturn("hello")`, which may generate `ClassCastExceptions` if the cast fails
* With the generic method, the compiler will perform careful type checking and infer the return type is String when the actual argument's type is String and inserts type cast automatically (such cast will never throw ClassCastException, guaranteed to be safe)
* Therefore, the code can be successfully compiled and is more type safe. The benefits become obvious shen the return type is also parameterized

## ArrayList
* Arrays store wequences of objects (and primitive values). Arrays do not change their size at runtime to accommodate additional elements
* ArrayList<T> can dynamically change its size at runtime
* ArrayList<T> is a generic class, where `T` is a placeholder for tye type of elements that you want the ArrayList to hold
  ```java
  ArrayList<String> list;
  ```
  > Declares list as an ArrayList collection to store only String objects
  
```java
import java.util.ArrayList;

public class Arraylist {
  public static void main(String[] args) {
    ArrayList<String> list = new ArrayList<String>();
    printList(list);
    list.add("hello");
    printList(list);
    list.add("world");
    printList(list);
    list.add(1, "java");
    printList(list);
  }

  public static void printList(ArrayList<String> list) { // traverse the list
    for (String s : list)
      System.out.printf("%s ", s); // enhanced for loop
    System.out.println();
  }
} 
```
Output
```
hello
hello world
hello java world
```
  
## Removing Elements from ArrayList
```java
public class RemoveArraylist {
  public static void main(String[] args) {
  ArrayList<String> list = new ArrayList<String>();
  list.add("hello");
  list.add("world");
  System.out.printf("The list contains %d element(s)\n", list.size());
  for (int i = 0; i < list.size(); i++) {
    if (list.get(i).startsWith("w"))
      list.remove(i);
  }
  System.out.printf("After removing, the list contains %d element(s)\n", list.size());
  }
} 
```
Output
```
The list contains 2 element(s)
After removing, the list contains 1 element(s)                                 
```
                         
